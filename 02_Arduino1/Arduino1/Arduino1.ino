/***********************************************************************/
/*                                                                     */
/*  FILE        :Arduino1.ino                                          */
/*  DATE        :May 10, 2020                                          */
/*  DESCRIPTION :ROSロボ Arduino1用プログラム                          */
/*                                                                     */
/*  This file is generated by Tatsuya Miyazaki                         */
/*                                                                     */
/***********************************************************************/
#include <ros.h>
#include <geometry_msgs/Twist.h>
#include <std_msgs/Int32.h>
#include <std_msgs/UInt32.h>
#include <std_msgs/Bool.h>

#include "CTimer.hpp"
#include "CMotor.hpp"
#include "CBumper.hpp"
#include "comA1andA2.hpp"
#include "pid.hpp"
#include "fix.hpp"
#include "SpeedController.hpp"

#define ROSROBO_VER 2    // ROSロボのバージョン（第一世代：1、第二世代：2）

/***********************************************************************/
/*                           グローバル変数                            */
/***********************************************************************/
//PID用
//static pidType pid_state_right;
//static pidType pid_state_left;
//static arduino1StateType A1state;

// モータークラス
static CMotor gm;

/***********************************************************************/
/*                               ROS関数                               */
/***********************************************************************/
ros::NodeHandle nh;

//-------------------------------------------------------
//             cmd_velのサブスクライバー
//-------------------------------------------------------
#define WHEEL_TRACK 0.0625f // 車輪左右間隔[m]
#define MAX_VELOCITY 0.7f // デューティ100％の時の速度[m/s]
#define R_MOTOR_SPEC 1.0f // モーターの固有ばらつき補正値
#define L_MOTOR_SPEC 1.0f // モーターの固有ばらつき補正値
//#define L_MOTOR_SPEC 0.98f
#define DUTY_MIN 15       // モーターが回転し始める最小のDUTY比

void messageCb2(const geometry_msgs::Twist& twist) {
  const float linear_x = twist.linear.x;
  const float angular_z = twist.angular.z;
  //int32_t linear_x = (int32_t)twist.linear.x;
  //int32_t angular_z = (int32_t)twist.angular.z;
  int32_t motorR = 0;
  int32_t motorL = 0;
  float velocityR = linear_x - WHEEL_TRACK * angular_z;
  float velocityL = linear_x + WHEEL_TRACK * angular_z;

  if (velocityR > MAX_VELOCITY) {
    velocityR = MAX_VELOCITY;
  } else if (velocityR < -MAX_VELOCITY) {
    velocityR = -MAX_VELOCITY;
  }
  if (velocityL > MAX_VELOCITY) {
    velocityL = MAX_VELOCITY;
  } else if (velocityL < -MAX_VELOCITY) {
    velocityL = -MAX_VELOCITY;
  }

  //pid_state_right.desired = - FLOAT_TO_FIX(velocityR);
  //pid_state_left.desired =  FLOAT_TO_FIX(velocityL);

  motorR = (int32_t)(velocityR / MAX_VELOCITY * 100.0 * R_MOTOR_SPEC);
  motorL = (int32_t)(velocityL / MAX_VELOCITY * 100.0 * L_MOTOR_SPEC);

  gm.driveMotors(motorR, motorL);
}

// cmd_velを取得するサブスクライバー
ros::Subscriber<geometry_msgs::Twist> sub2("arduino_cmd_vel", &messageCb2);

//-------------------------------------------------------
//         バンパーステータスののパブリッシャー
//-------------------------------------------------------
// バンパートピック
std_msgs::Bool bumper_msg;
ros::Publisher pubBumper("Bumper", &bumper_msg);

//-------------------------------------------------------
//         エンコーダカウントのパブリッシャー
//-------------------------------------------------------
// エンコーダデータ
std_msgs::Int32 encR_msg;
std_msgs::Int32 encL_msg;
std_msgs::UInt32 time_msg;

//Publisherのインスタンス
//トピック名：encR, encL, time_A2
ros::Publisher pub3("A2_encR", &encR_msg);
ros::Publisher pub4("A2_encL", &encL_msg);
ros::Publisher pub5("A2_time", &time_msg);

/***********************************************************************/
/*                               main関数                              */
/***********************************************************************/
void setup() {
  // Arduino2とのI2C通信設定
  initComA1andA2(SLAVE);

  //PIDパラメータの設定
  //initPID(&pid_state_right, KTT, &A1state.vel_right, FLOAT_TO_FIX(0.5), 0.3, 1.5, 0.0);
  //initPID(&pid_state_left, KTT, &A1state.vel_left, FLOAT_TO_FIX(0.5), 0.3, 1.5, 0.0);
  //Serial.begin(115200);
  delay(1000);
}

void loop() {
  // バンパークラス
  static CBumper gb;
  // タイマークラス
  static CTimer rosTimer;   // rosserial用
  static CTimer bpTimer;    // バンパー用

  static uint8_t encUpdFlag = 0;
  static uint8_t encUpdFlag2 = 0;
  static arduino2StateType A2state;       // Arduino2の状態量
  //SpeedControll spdControll;              //速度制御インスタンス生成
  //fix power_right = 10;
  //fix power_left = 10;

  //目標速度の設定
  //pid_state_right.desired = FLOAT_TO_FIX(0.5);
  //pid_state_left.desired = FLOAT_TO_FIX(0.5);

  // エンコーダ値更新処理
  if (isI2Crecieved()) {
    i2cSlaveRecieve(&A2state);
    encUpdFlag++;
    encUpdFlag2++;
  }
/*
  // 速度計算
  if (encUpdFlag2) {
    encUpdFlag2 = 0;
    spdControll.calcSpeed(A2state, &A1state);                //現在速度の計算
    power_right = pidControl(&pid_state_right, FILT_FREQ);   //PID制御量を計算
    power_left = pidControl(&pid_state_left, FILT_FREQ);
    spdControll.controllMotorsSpeed(power_right, power_left, A1state);
    //gm.driveMotors(spdControll.duty_status.duty_right, spdControll.duty_status.duty_left);    //モーターにデューティ比を指令
  }
*/
  // バンパーのサンプリング(Bumper.hppのSAMPLE_FREQ [Hz]で実行)
  if (bpTimer.getTime() >= 50) {
    bpTimer.startTimer();
    gb.bumperSampling();
  }

  // ROSへの周期的なパブリッシュ
  if (rosTimer.getTime() >= 50) {
    rosTimer.startTimer();

    if (!nh.connected()) {   // rosserialが切れたら、再接続する
      nh.getHardware()->setBaud(115200);
      nh.initNode();
      nh.subscribe(sub2);
      nh.advertise(pubBumper);
      nh.advertise(pub3);
      nh.advertise(pub4);
      nh.advertise(pub5);
      //Serial.print("reconnecting");
      while (!nh.connected()) {
        //Serial.print(".");
        nh.spinOnce();
        digitalWrite(30,LOW);   // 接続できないときはLEDを点滅させる
        delay(500);
        digitalWrite(30,HIGH);
        delay(500);
      }
      //Serial.println("Connect.");
    } else {                    // rosserialが接続しているときの動作
      digitalWrite(30,HIGH);    // LED消灯
      // バンパー値をパブリッシュ
      if (gb.isBumperChanged()) {
        bumper_msg.data = gb.readBumper();
        pubBumper.publish(&bumper_msg);
      }

      // エンコーダ値をパブリッシュ
      if (encUpdFlag) {
        encUpdFlag = 0;
        encR_msg.data = A2state.encR;
        encL_msg.data = A2state.encL;
        time_msg.data = A2state.time;
        pub3.publish(&encR_msg);
        pub4.publish(&encL_msg);
        pub5.publish(&time_msg);
      }
    }
  }
  nh.spinOnce();
}
