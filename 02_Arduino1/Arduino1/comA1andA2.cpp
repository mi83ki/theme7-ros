/***********************************************************************/
/*                                                                     */
/*  FILE        :comA1andA2-r00.cpp                                    */
/*  DATE        :Oct. 19, 2019                                         */
/*  DESCRIPTION :ROSロボ Arduino1-Arduino2間通信用プログラム           */
/*                                                                     */
/*  This file is generated by Tatsuya Miyazaki                         */
/*                                                                     */
/*  メモ：                                                             */
/*        R00：新規作成                                                */
/*                                                                     */
/***********************************************************************/

#ifndef _COM_A1_AND_A2_CPP__
#define _COM_A1_AND_A2_CPP__

#include <Wire.h>
#include "comA1andA2.hpp"


/***********************************************************************/
/*                                                                     */
/*  FILE        :queue.c                                               */
/*  DATE        :Wed, Jun 14, 2009                                     */
/*  DESCRIPTION :Queue Program                                         */
/*  CPU TYPE    :SH7047                                                */
/*                                                                     */
/*  This file is generated by Tatsuya Miyazaki                         */
/*                                                                     */
/***********************************************************************/

//#include "queue.h"

#ifndef _QUEUE_CPP__
#define _QUEUE_CPP__


/***********************************************************************/
/*                     静的な領域を利用するFIFO                        */
/***********************************************************************/

uint16_t queueNext(uint16_t n, uint16_t size) {
  return((n + 1) % (size));
}

uint8_t isQueueEmpty(queueType *que) {
  return(que->front == que->rear);
}

uint8_t isQueueFull(queueType *que) {
  return(queueNext(que->rear, que->size) == que->front);
}

uint8_t enqueue(queueType *que, queue_t x) {
  if(isQueueFull(que)) {
    return(0);
  } else {
    que->data[que->rear] = x;
    que->rear = queueNext(que->rear, que->size);
    return(1);
  }
}

queue_t dequeue(queueType *que) {
  queue_t x;

  if(isQueueEmpty(que)) {
    return(0);
  } else {
    x = que->data[que->front];
    que->front = queueNext(que->front, que->size);
    return(x);
  }
}

int8_t *getQueueName(queueType *que) {
  return(que->name);
}

#endif


/***********************************************************************/
/*                           グローバル変数                            */
/***********************************************************************/
// 送信データバッファ
static queue_t bufCode2[SIZE_OF_CODE2 + 1];
static queueType queueCode2 = {bufCode2, SIZE_OF_CODE2 + 1, 0, 0, "queueCode2"};

/***********************************************************************/
/*                                関数                                 */
/***********************************************************************/
void initComA1andA2(uint8_t select) {
  uint8_t temp;
  if (select == SLAVE) {
    //Serial.println("I2C Slave!");
    Wire.begin(8);                // join i2c bus with address #8
    Wire.onReceive(i2cRecieveInterrupt); // register event
  } else if (select == MASTER) {
    //Serial.println("I2C Master!");
    Wire.begin(); // join i2c bus (address optional for master)
  }
}

// 32bitのデータを変換する
uint8_t encode32bit(int32_t data) {
  int32uType temp;

  temp.cnt32 = data;
  // 上位から7bitずつ抽出して待ち行列に追加する
  if (!enqueue(&queueCode2, temp.cnt7.b31to25)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b24to18)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b17to11)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b10to04)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b03to00 << 3)) return(0);
  return(1);
}

// 符号なし32bitのデータを変換する
uint8_t encodeU32bit(uint32_t data) {
  uint32uType temp;

  temp.cnt32 = data;
  // 上位から7bitずつ抽出して待ち行列に追加する
  if (!enqueue(&queueCode2, temp.cnt7.b31to25)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b24to18)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b17to11)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b10to04)) return(0);
  if (!enqueue(&queueCode2, temp.cnt7.b03to00 << 3)) return(0);
  return(1);
}


// 現在のエンコーダ値（encRとencL）を変換して待ち行列に追加する
uint8_t encode2(arduino2StateType a2st) {
  // STXを待ち行列に追加する
  if (!enqueue(&queueCode2, STX)) return(0);
  
  // encRを待ち行列に追加する
  if (!encode32bit(a2st.encR)) return(0);

  // encLを待ち行列に追加する
  if (!encode32bit(a2st.encL)) return(0);

  // timeを待ち行列に追加する
  if (!encodeU32bit(a2st.time)) return(0);
  //if (!encode32bit(a2st.time)) return(0);

  // ETXを待ち行列に追加する
  if (!enqueue(&queueCode2, ETX)) return(0);

  return(1);
}

// 変換された32bitのデータを復元する
uint8_t decode32bit(int32_t *data) {
  int32uType temp;

  // 上位から7bitずつ復元する
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b31to25 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b24to18 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b17to11 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b10to04 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b03to00 = dequeue(&queueCode2) >> 3;

  *data = temp.cnt32;
  return(1);
}

// 変換された符号なし32bitのデータを復元する
uint8_t decodeU32bit(uint32_t *data) {
  uint32uType temp;

  // 上位から7bitずつ復元する
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b31to25 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b24to18 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b17to11 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b10to04 = dequeue(&queueCode2);
  if (isQueueEmpty(&queueCode2)) return(0);
  temp.cnt7.b03to00 = dequeue(&queueCode2) >> 3;

  *data = temp.cnt32;
  return(1);
}

// 受信したバイナリデータをエンコーダ値（encRとencL）に復元する
uint8_t decode2(arduino2StateType *a2st) {
  uint8_t rxData;
  arduino2StateType tempSt = {0};

  while(!isQueueEmpty(&queueCode2)) {
    rxData = dequeue(&queueCode2);
    if (rxData == STX) {
      if (!decode32bit(&tempSt.encR)) return(0);
      if (!decode32bit(&tempSt.encL)) return(0);
      if (!decodeU32bit(&tempSt.time)) return(0);
      //if (!decode32bit(&tempSt.time)) return(0);
      if (isQueueEmpty(&queueCode2)) return(0);
      rxData = dequeue(&queueCode2);
      if (rxData == ETX) {
        a2st->encR = tempSt.encR;
        a2st->encL = tempSt.encL;
        a2st->time = tempSt.time;
        return(1);
      }
    }
  }
  return(0);
}


// マスター側の送信動作（Arduino2）
uint8_t i2cMasterTransmit(arduino2StateType a2st) {
  uint8_t size = 0;
  while (!isQueueEmpty(&queueCode2)) {
    dequeue(&queueCode2);
  }
  encode2(a2st);
  Wire.beginTransmission(8); // transmit to device #8
  while(!isQueueEmpty(&queueCode2)) {
    byte c = dequeue(&queueCode2); // receive byte as a character
    Wire.write(c);
    size++;
  }
  Wire.endTransmission();    // stop transmitting
  return(size);
}

// スレーブ側の受信割込み動作（Arduino1）
static uint8_t i2cRecievedFlag = 0;

void i2cRecieveInterrupt(void) {
  i2cRecievedFlag++;
}

// I2Cで受信データが更新されたかどうか
uint8_t isI2Crecieved(void) {
  return(i2cRecievedFlag);
}


// スレーブ側の受信動作（Arduino1）
uint8_t i2cSlaveRecieve(arduino2StateType *A2state) {
  i2cRecievedFlag = 0;
  while (!isQueueEmpty(&queueCode2)) {
    dequeue(&queueCode2);
  }
  while (Wire.available()) { // loop through all
    byte c = Wire.read(); // receive byte as a character
    if (!enqueue(&queueCode2, c)) return(0);
  }
  if(!decode2(A2state)) {  // エンコーダ値を更新
    Serial.println("failed to decode2");
    return(0);
  }
  return(1);
}



#endif
